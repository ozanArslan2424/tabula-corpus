import C, { Method } from "@/index";
import { describe, expect, it } from "bun:test";
import { createTestServer } from "./utils/createTestServer";
import { req, TEST_PORT } from "./utils/req";
import net from "net";

const s = createTestServer();

describe("Security", () => {
	// ─── route matching ───────────────────────────────────────────

	it("SECURITY - ROUTE - DOES NOT MATCH PARTIAL PATH", async () => {
		new C.Route("/secure", () => "secret");

		const res = await s.handle(req("/secure/extra"));
		expect(res.status).toBe(404);
	});

	it("SECURITY - ROUTE - DOES NOT MATCH PATH TRAVERSAL", async () => {
		new C.Route("/files/:name", (c) => {
			console.log(c.params);
			return "ok";
		});

		const res = await s.handle(req("/files/../../etc/passwd"));
		expect(res.status).toBe(404);
		const res2 = await s.handle(req("%2Ffiles%2F..%2F..%2Fetc%2Fpasswd"));
		expect(res2.status).toBe(404);
		const res3 = await s.handle(
			req("path.join('files','..','..','etc','passwd')"),
		);
		expect(res3.status).toBe(404);
	});

	it("SECURITY - ROUTE - DOES NOT MATCH NULL BYTE INJECTION", async () => {
		new C.Route("/api/users", () => "users");

		const res = await s.handle(req("/api/users%00"));
		expect(res.status).toBe(404);
	});

	it("SECURITY - ROUTE - METHOD NOT ALLOWED ON WRONG METHOD", async () => {
		new C.Route({ method: Method.POST, path: "/post-only" }, () => "post");

		const res = await s.handle(req("/post-only", { method: "DELETE" }));
		expect(res.status).toBe(405);
	});

	// ─── body ─────────────────────────────────────────────────────

	it("SECURITY - BODY - DEEPLY NESTED JSON DOES NOT CRASH", async () => {
		new C.Route({ method: Method.POST, path: "/deep-json" }, (c) => c.body);

		const deep = JSON.parse(
			Array.from({ length: 100 }, () => '{"a":').join("") +
				'"val"' +
				Array.from({ length: 100 }, () => "}").join(""),
		);
		const res = await s.handle(
			req("/deep-json", {
				method: "POST",
				headers: { "Content-Type": "application/json" },
				body: JSON.stringify(deep),
			}),
		);
		expect(res.status).toBe(200);
	});

	it("SECURITY - BODY - MALFORMED JSON RETURNS EMPTY OBJECT", async () => {
		new C.Route({ method: Method.POST, path: "/bad-json" }, (c) => c.body);

		const res = await s.handle(
			req("/bad-json", {
				method: "POST",
				headers: { "Content-Type": "application/json" },
				body: "{not: valid json!!!}",
			}),
		);
		expect(res.status).toBe(200);
		const data = await C.Parser.getBody(res);
		expect(data).toBeEmptyObject();
	});

	it("SECURITY - BODY - PROTOTYPE POLLUTION VIA JSON IS NOT APPLIED", async () => {
		new C.Route({ method: Method.POST, path: "/proto-json" }, (c) => c.body);

		const res = await s.handle(
			req("/proto-json", {
				method: "POST",
				headers: { "Content-Type": "application/json" },
				body: JSON.stringify({
					__proto__: { polluted: true },
					constructor: { prototype: { polluted: true } },
				}),
			}),
		);
		expect(res.status).toBe(200);
		expect(({} as any).polluted).toBeUndefined();
	});

	it("SECURITY - BODY - PROTOTYPE POLLUTION VIA FORM URLENCODED IS NOT APPLIED", async () => {
		new C.Route({ method: Method.POST, path: "/proto-form" }, (c) => c.body);

		const res = await s.handle(
			req("/proto-form", {
				method: "POST",
				headers: { "Content-Type": "application/x-www-form-urlencoded" },
				body: "__proto__[polluted]=true&constructor[prototype][polluted]=true",
			}),
		);
		expect(res.status).toBe(200);
		expect(({} as any).polluted).toBeUndefined();
	});

	// ─── search params ────────────────────────────────────────────

	it("SECURITY - SEARCH - XSS PAYLOAD IS RETURNED AS PLAIN STRING", async () => {
		new C.Route("/xss-search", (c) => c.search);

		const res = await s.handle(req("/xss-search?q=<script>alert(1)</script>"));
		const data = await C.Parser.getBody<Record<string, unknown>>(res);
		expect(data.q).toBe("<script>alert(1)</script>");

		const res2 = await s.handle(req("/xss-search?q=console.log(1)"));
		const data2 = await C.Parser.getBody<Record<string, unknown>>(res2);
		expect(data2.q).toBe("console.log(1)");
	});

	it("SECURITY - SEARCH - SQL INJECTION PAYLOAD IS RETURNED AS PLAIN STRING", async () => {
		new C.Route("/sql-search", (c) => (c.search as any).q);

		const res = await s.handle(req("/sql-search?q=1' OR '1'='1"));
		const data = await C.Parser.getBody<string>(res);
		expect(res.headers.get(C.CommonHeaders.ContentType)).toBe("text/plain");
		expect(data).toBe("1' OR '1'='1");
	});

	// ─── params ───────────────────────────────────────────────────

	it("SECURITY - PARAMS - XSS PAYLOAD IN PARAM IS RETURNED AS PLAIN STRING", async () => {
		new C.Route("/xss-param/:id", (c) => (c.params as any).id);

		const res = await s.handle(
			req("/xss-param/%3Cscript%3Ealert(1)%3C%2Fscript%3E"),
		);
		const data = await C.Parser.getBody<string>(res);
		expect(res.headers.get(C.CommonHeaders.ContentType)).toBe("text/plain");
		expect(data).toBe("<script>alert(1)</script>");
	});

	// ─── headers ──────────────────────────────────────────────────

	it("SECURITY - HEADERS - HEADER INJECTION PAYLOAD IS REJECTED BY RUNTIME", () => {
		expect(() =>
			req("/header-injection", {
				headers: { "x-input": "legit\r\nx-injected: evil" },
			}),
		).toThrow(TypeError);
	});

	it("SECURITY - HEADERS - UNSUPPORTED CONTENT TYPE RETURNS 422", async () => {
		new C.Route({ method: Method.POST, path: "/bad-ct" }, (c) => c.body);

		const res = await s.handle(
			req("/bad-ct", {
				method: "POST",
				headers: { "Content-Type": "video/mp4" },
				body: "fake-video-data",
			}),
		);
		expect(res.status).toBe(422);
	});

	it("SECURITY - HEADERS - ARBITRARY REQUEST HEADERS DO NOT PROPAGATE TO RESPONSE", async () => {
		new C.Route("/header-no-propagate", (c) => {
			c.res.headers.set("x-output", c.headers.get("x-input") ?? "");
			return "ok";
		});

		await s.listen(TEST_PORT);

		const rawRequest =
			"GET /header-no-propagate HTTP/1.1\r\n" +
			"Host: localhost\r\n" +
			"x-input: legit\r\n" +
			"x-injected: evil\r\n" +
			"\r\n";

		const rawResponse = await new Promise<string>((resolve, reject) => {
			let data = "";
			const socket = net.createConnection({
				port: TEST_PORT,
				host: "localhost",
			});
			socket.on("connect", () => socket.write(rawRequest));
			socket.on("data", (chunk) => {
				data += chunk.toString();
				socket.end();
			});
			socket.on("end", () => resolve(data));
			socket.on("error", reject);
		});

		await s.close();

		// x-injected was sent in the request but should never appear in the response
		const responseHeaders = rawResponse.split("\r\n\r\n")[0];
		expect(responseHeaders).not.toContain("x-injected");
		expect(responseHeaders).not.toContain("evil");
		expect(responseHeaders).toContain("x-output: legit");
	});

	// ─── cookies ──────────────────────────────────────────────────

	it("SECURITY - COOKIES - XSS PAYLOAD IN COOKIE IS RETURNED AS PLAIN STRING", async () => {
		new C.Route("/xss-cookie", (c) => {
			return c.cookies.get("session");
		});

		const res = await s.handle(
			req("/xss-cookie", {
				headers: { cookie: "session=<script>alert(1)</script>" },
			}),
		);
		const data = await C.Parser.getBody<string>(res);
		expect(res.headers.get(C.CommonHeaders.ContentType)).toBe("text/plain");
		expect(data).toBe("<script>alert(1)</script>");
	});

	// ─── middleware ───────────────────────────────────────────────

	it("SECURITY - MIDDLEWARE - DATA FROM ONE ROUTE DOES NOT LEAK TO ANOTHER", async () => {
		new C.Route("/secret-data", (c) => {
			c.data = { secret: "top-secret" };
			return "ok";
		});
		new C.Route("/other-data", (c) => c.data);

		await s.handle(req("/secret-data"));
		const res = await s.handle(req("/other-data"));
		const data = await C.Parser.getBody<Record<string, unknown>>(res);
		expect(data.secret).toBeUndefined();
	});
});
